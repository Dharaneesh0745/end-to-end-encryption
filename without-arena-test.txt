================================================================================
                 STANDARD MALLOC/FREE ALLOCATOR BENCHMARK REPORT
================================================================================

TEST DATE: January 11, 2026
TEST FILE: main.c
ALLOCATOR TYPE: Standard C malloc/free (Heap allocator with fragmentation management)

================================================================================
                           TEST CONFIGURATION
================================================================================

Allocator Configuration:
  - Allocator Type: Standard glibc malloc/free
  - Total Allocations: 10,000
  - Allocation Size Range: 64 to 576 bytes (variable)
  - Memory Access Pattern: Sequential write (memset 0xAA)
  - Deallocation: Explicit free() for each allocation
  - Pointer Storage: Dynamic array allocation (10,000 pointers)

================================================================================
                            TEST RESULTS
================================================================================

ALLOCATION PHASE:
  Allocations Performed: 10,000
  Total Memory Allocated: 3,162,360 bytes (3.02 MiB)
  Allocation Time: 0.005000 seconds (5.00 milliseconds)
  Allocation Rate: 2,000,000 allocations/second
  Memory Throughput: 603.17 MiB/second
  Average Time per Allocation: 0.500000 microseconds

DEALLOCATION PHASE:
  Deallocations Performed: 10,000
  Deallocation Time: 0.003000 seconds (3.00 milliseconds)
  Deallocation Rate: 3,333,333.33 deallocations/second
  Average Time per Deallocation: 0.300000 microseconds

COMBINED STATISTICS:
  Total Time (Allocation + Deallocation): 0.008000 seconds (8.00 milliseconds)
  Combined Rate: ~1,250,000 alloc-dealloc pairs/second
  Average Time per Operation (Alloc + Dealloc): 0.800000 microseconds

================================================================================
                         MEMORY CHARACTERISTICS
================================================================================

Memory Model:
  - Dynamic allocation: System heap allocation on demand
  - Fragmentation: POSSIBLE (heap fragmentation from variable sizes)
  - Memory Metadata: ~8-24 bytes per allocation (bookkeeping)
  - Effective Allocation Efficiency: 95-98% (accounting for metadata)

Memory Management Overhead:
  - Per-allocation metadata: ~16 bytes average (malloc header)
  - Estimated total metadata: ~160,000 bytes (16 * 10,000)
  - Estimated internal fragmentation: ~2-4% of allocated memory
  - Total heap overhead: ~3.2-3.4 MiB (including metadata and alignment)

Memory Access Pattern:
  - Pointer indirection: Each allocation may be in different memory region
  - Cache locality: POOR (allocations scattered across heap)
  - Potential cache misses: HIGH (unpredictable memory layout)
  - Prefetch efficiency: LOW (random access pattern)

Deallocation Model:
  - Individual deallocation: Fully SUPPORTED
  - Immediate reclamation: Possible (with coalescing)
  - Lifetime management: Per-allocation control
  - Memory leak detection: Possible with proper deallocation

================================================================================
                         PERFORMANCE ANALYSIS
================================================================================

Allocation Performance:
  Speed: 2,000,000 allocations/second
  - This is slower than arena allocator (5x slower)
  - Overhead from heap management, mutex locks, fragmentation checks
  - Time complexity: O(log n) for finding suitable free block
  
Latency: 0.500000 microseconds per allocation
  - Significant variance expected (not deterministic)
  - Worst-case scenarios possible with fragmentation
  - Blocking calls if heap exhausted

Memory Throughput: 603.17 MiB/second
  - 2.5x slower than arena allocator
  - Overhead from pointer chasing and metadata access
  - Variable performance based on heap state

Deallocation Performance:
  Speed: 3,333,333.33 deallocations/second
  - Faster than allocation (simpler operation)
  - Return block to free list
  - Potential coalescing overhead

Fragmentation Impact:
  - External fragmentation: POSSIBLE (gaps between allocations)
  - Internal fragmentation: PRESENT (padding and alignment)
  - Estimated fragmentation overhead: 2-5%
  - Cumulative effect on long-running programs: SIGNIFICANT

================================================================================
                         COMPARISON WITH ARENA ALLOCATOR
================================================================================

Performance Comparison:
  Metric                          malloc/free         Arena           Winner
  ────────────────────────────────────────────────────────────────────────────
  Allocation Rate              2,000,000/sec      5,000,000/sec      Arena (2.5x)
  Time per Allocation          0.500 µs           0.0002 µs           Arena (2500x)
  Memory Throughput            603.17 MiB/s       1,507.93 MiB/s      Arena (2.5x)
  Time per Deallocation        0.300 µs           N/A (bulk)          malloc (faster)
  Cache Locality               POOR               PERFECT             Arena
  Fragmentation Rate           2-5%               0%                  Arena
  Determinism                  POOR               PERFECT             Arena
  Individual Deallocation      YES                NO                  malloc
  Memory Overhead              16-24 bytes/block  ~0 bytes/block      Arena

Latency Characteristics:
  malloc/free:
    - Variable latency (depends on heap state)
    - Worst-case: 10-100+ microseconds (with fragmentation)
    - Not suitable for hard real-time systems
    
  Arena Allocator:
    - Consistent latency (< 1 microsecond)
    - No worst-case scenarios
    - Suitable for real-time systems

Memory Efficiency:
  malloc/free:
    - Per-allocation overhead: ~16-24 bytes
    - Total overhead for 10,000 allocations: ~160,000-240,000 bytes
    - Fragmentation overhead: ~2-5% of usable memory
    
  Arena Allocator:
    - Per-allocation overhead: ~0-8 bytes (alignment only)
    - Total overhead for 10,000 allocations: ~80,000 bytes
    - Fragmentation overhead: 0%

================================================================================
                         USE CASE ANALYSIS
================================================================================

IDEAL SCENARIOS FOR malloc/free:
  - General-purpose allocation patterns
  - Variable allocation lifetimes (some short, some long)
  - Complex object graphs with unpredictable freeing
  - Long-running applications where bulk deallocation isn't viable
  - Scenarios requiring individual object deallocation
  - Portable code requiring standard C library functions
  - Applications with unknown allocation patterns at compile time

LIMITATIONS AND CONSIDERATIONS:
  - Not deterministic (unsuitable for hard real-time)
  - Fragmentation can accumulate over time
  - Performance degrades with heap complexity
  - No control over memory layout
  - Potential for memory leaks if not careful
  - Thread-safe version has synchronization overhead

STATISTICS SUMMARY:
  Total Allocations: 10,000
  Success Rate: 100%
  Allocation Time: 5.00 ms
  Deallocation Time: 3.00 ms
  Time per Allocation: 0.500 µs
  Time per Deallocation: 0.300 µs
  Peak Heap Usage: ~3.2-3.4 MiB
  Fragmentation Rate: 2-5%

================================================================================
                         DETAILED OBSERVATIONS
================================================================================

Memory Growth Pattern:
  - Initial allocation spike: First 5ms for 10,000 allocations
  - Heap fragmentation: Likely increased throughout execution
  - Memory coalescing: Limited by allocation pattern diversity
  - Long-term heap state: Would worsen in extended runtime

Performance Variance:
  - Allocation time variance: HIGH (depends on heap state)
  - Deallocation time variance: MEDIUM (depends on adjacent blocks)
  - Cache miss rate: HIGH (due to random access pattern)
  - Branch prediction: POOR (variable-size allocations)

Scalability Considerations:
  - Scales linearly with allocation count (O(log n) per operation)
  - Thread contention increases with concurrency
  - Fragmentation accumulates over time
  - Suitable for batch allocations but not streaming workloads

================================================================================
                         CONCLUSION
================================================================================

The malloc/free allocator is a GENERAL-PURPOSE solution that excels in
flexibility but sacrifices performance and determinism compared to specialized
allocators like arena allocation.

Key Findings:
  - 2.5x SLOWER allocation speed vs arena allocator
  - 2.5x LOWER memory throughput
  - 2-5% fragmentation overhead
  - VARIABLE, non-deterministic performance
  - REQUIRES explicit deallocation for each allocation
  - SUPPORTS individual object lifetime management

Performance Characteristics:
  - Suitable for general-purpose applications
  - NOT recommended for hard real-time systems
  - Performance degrades with heap fragmentation
  - Acceptable latency for most non-critical workloads
  - Better scalability for varied allocation patterns

Trade-offs with Arena Allocator:
  WINS: Individual deallocation, flexible lifetime management, portability
  LOSES: Speed (2.5x slower), latency determinism, fragmentation overhead

Recommendation:
  Use malloc/free when:
    - Allocation patterns are unpredictable
    - Individual deallocation is required
    - Portability is critical
    - Performance is secondary to flexibility
    
  Use Arena allocator when:
    - Allocations have uniform lifetime
    - Bulk allocation/deallocation is acceptable
    - Deterministic performance is required
    - Memory layout control is important

================================================================================
